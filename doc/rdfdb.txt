The central module of the RDF infrastructure is library(semweb/rdf_db).
It provides storage and indexed querying of RDF triples. RDF data is
stored as quintuples. The first three elements denote the RDF triple.
The extra _Graph_ and _Line_ elements provide information about the
origin of the triple.

The actual storage is provided by the _|foreign language (C)|_ module.
Using a dedicated C-based implementation we can reduced memory usage and
improve indexing capabilities, for example by providing a dedicated
index to support entailment over =|rdfs:subPropertyOf|=. Currently the
following indexes are provided (S=subject, P=predicate, O=object,
G=graph):

  * S, P, O, SP, PO, SPO, G, SG, PG

  * Predicates connect by *|rdfs:subPropertyOf|* are combined
    in a _|predicate cloud|_.  The system causes multiple
    predicates in the cloud to share the same hash.  The cloud
    maintains a 2-dimensional array that expresses the
    closure of all rdfs:subPropertyOf relations.  This
    index supports rdf_has/3 to query a property and all its
    children efficiently.

  * Additional indexes for predicates, resources and graphs allow
    enumerating these objects without duplicates.  For example,
    using rdf_resource/1 we enumerate all resources in the database
    only once, while enumeration using e.g., =|(rdf(R,_,_);rdf(_,_,R))|=
    normally produces many duplicate answers.

  * Literal _Objects_ are combined in a _|skip list|_ after case
    normalization. This provides for efficient case-insensitive search,
    prefix and range search. The plugin library library(semweb/litindex)
    provides indexed search on tokens inside literals.

---++ Query the RDF database

  * [[rdf/3]]
  * [[rdf/4]]
  * [[rdf_has/3]]
  * [[rdf_has/4]]
  * [[rdf_reachable/3]]
  * [[rdf_reachable/5]]

---++ Enumerating objects

The predicates below enumerate the basic objects  of the RDF store. Most
of these predicates also enumerate objects   that  are not associated to
any currently visible triple. Objects are retained   as long as they are
visible in active queries or _snapshots_. After that, some are reclaimed
by the RDF garbage collector, while others are never reclaimed.

  * [[rdf_subject/1]]
  * [[rdf_resource/1]]
  * [[rdf_current_predicate/1]]
  * [[rdf_current_literal/1]]
  * [[rdf_graph/1]]
  * [[rdf_current_ns/2]]

---++ Modifying the RDF database

The predicates below modify the RDF   store  directly. In addition, data
may be loaded using rdf_load/2  or   by  restoring a persistent database
using rdf_attach_db/2. Modifications follow the  Prolog _|logical update
view|_ semantics, which implies that   modifications remain invisible to
already  running  queries.  Further  isolation  can  be  achieved  using
rdf_transaction/3.

  * [[rdf_assert/3]]
  * [[rdf_assert/4]]
  * [[rdf_retractall/3]]
  * [[rdf_retractall/4]]
  * [[rdf_update/4]]
  * [[rdf_update/5]]

---++ Update view, transactions and snapshots

The update semantics of the RDF database follows the conventional Prolog
_|logical update view|_. In addition, the RDF database supports
_transactions_ and _snapshots_.

  * [[rdf_transaction/1]]
  * [[rdf_transaction/2]]
  * [[rdf_transaction/3]]
  * [[rdf_snapshot/1]]
  * [[rdf_delete_snapshot/1]]
  * [[rdf_active_transaction/1]]
  * [[rdf_current_snapshot/1]]

---++ Loading and saving to file

The RDF library can read and write triples in RDF/XML and a proprietary
binary format. There is a plugin interface defined to support additional
formats.  The library(semweb/rdf_turtle) uses this plugin API to support
loading Turtle files using rdf_load/2.

  * [[rdf_load/1]]
  * [[rdf_load/2]]
  * [[rdf_unload/1]]
  * [[rdf_save/1]]
  * [[rdf_save/2]]
  * [[rdf_make/0]]

---+++ Partial save

Sometimes it is necessary to make more arbitrary selections of material
to be saved or exchange RDF descriptions over an open network link. The
predicates in this section provide for this. Character encoding issues
are derived from the encoding of the _Stream_, providing support for
=utf8=, =iso_latin_1= and =ascii=.

  * [[rdf_save_header/2]]
  * [[rdf_save_footer/1]]
  * [[rdf_save_subject/3]]

---+++ Fast loading and saving

Loading and saving RDF format is relatively slow. For this reason we
designed a binary format that is more compact, avoids the complications
of the RDF parser and avoids repetitive lookup of (URL) identifiers.
Especially the speed improvement of about 25 times is worth-while when
loading large databases. These predicates are used for caching by
rdf_load/2 under certain conditions as well as for maintaining
persistent snapshots of the database using
library(semweb/rdf_persistency).

  * [[rdf_save_db/1]]
  * [[rdf_save_db/2]]
  * [[rdf_load_db/1]]


---++ Graph manipulation

Many RDF stores turned triples into quadruples. This store is no
exception, initially using the 4th argument to store the filename from
which the triple was loaded. Currently, the 4th argument is the RDF
_|named graph|_. A named graph maintains some properties, notably to
track origin, changes and modified state.

  * [[rdf_create_graph/1]]
  * [[rdf_unload_graph/1]]
  * [[rdf_graph_property/2]]
  * [[rdf_set_graph/2]]


---++ Literal matching and indexing

Literal values are ordered and indexed using a _|skip list|_ The aim of
this index is threefold.

  * Unlike hash-tables, binary trees allow for efficient
    _prefix_ and _range_ matching. Prefix matching
    is useful in interactive applications to provide feedback
    while typing such as auto-completion.
  * Having a table of unique literals we generate creation and
    destruction events (see rdf_monitor/2).  These events can
    be used to maintain additional indexing on literals, such
    as `by word'.  See library(semweb/litindex).

As string literal matching is most frequently used for searching
purposes, the match is executed case-insensitive and after removal of
diacritics. Case matching and diacritics removal is based on Unicode
character properties and independent from the current locale. Case
conversion is based on the `simple uppercase mapping' defined by Unicode
and diacritic removal on the `decomposition type'. The approach is
lightweight, but somewhat simpleminded for some languages. The tables
are generated for Unicode characters upto 0x7fff. For more information,
please check the source-code of the mapping-table generator
=|unicode_map.pl|= available in the sources of this package.

Currently the total order of literals is first based on the type of
literal using the ordering _|numeric < string < term|_ Numeric values
(integer and float) are ordered by value, integers preceed floats if
they represent the same value. strings are sorted alphabetically after
case-mapping and diacritic removal as described above. If they match
equal, uppercase preceeds lowercase and diacritics are ordered on their
unicode value. If they still compare equal literals without any
qualifier preceeds literals with a type qualifier which preceeds
literals with a language qualifier. Same qualifiers (both type or both
language) are sorted alphabetically.

The ordered tree is used for indexed execution of
literal(prefix(Prefix), Literal) as well as literal(like(Like), Literal)
if _Like_ does not start with a `*'. Note that results of queries that
use the tree index are returned in alphabetical order.

---++ Predicate properties

The predicates below form an experimental interface to provide more
reasoning inside the kernel of the rdb_db engine. Note that =symetric=,
=inverse_of= and =transitive= are not yet supported by the rest of the
engine. Alo note that there is no relation to defined RDF properties.
Properties that have no triples are not reported by this predicate,
while predicates that are involved in triples do not need to be defined
as an instance of rdf:Property.

  * [[rdf_set_predicate/2]]
  * [[rdf_predicate_property/2]]

---++ Prefix Handling

Prolog code often contains references to constant resources with a known
_prefix_ (also known as XML _namespace_). For example,
=|http://www.w3.org/2000/01/rdf-schema#Class|= refers to the most
general notion of an RDFS class. Readability and maintability concerns
require for abstraction here. The RDF database maintains a table of
known _prefixes_. This table can be queried using rdf_current_ns/2 and
can be extended using rdf_register_ns/3. The prefix database is used to
expand =|prefix:local|= terms that appear as arguments to calls which
are known to accept a _resource_. This expansion is achieved by Prolog
preprocessor using expand_goal/2.

  * [[rdf_current_ns/2]]
  * [[rdf_register_ns/2]]
  * [[rdf_register_ns/3]]

_Explicit_ expansion is achieved using the predicates below. The
predicate rdf_equal/2 performs this expansion at compile time, while the
other predicates do it at runtime.

  * [[rdf_equal/1]]
  * [[rdf_global_id/2]]
  * [[rdf_global_object/2]]
  * [[rdf_global_term/2]]

---+++ Namespace handling for custom predicates

If we implement a new predicate based on one of the predicates of the
semweb libraries that expands namespaces, namespace expansion is not
automatically available to it. Consider the following code computing the
number of distinct objects for a certain property on a certain object.

  ==
  cardinality(S, P, C) :-
        (   setof(O, rdf_has(S, P, O), Os)
        ->  length(Os, C)
        ;   C = 0
        ).
  ==

Now assume we want to write labels/2 that returns the number of distict
labels of a resource:

  ==
  labels(S, C) :-
        cardinality(S, rdfs:label, C).
  ==

This code will _not_ work because =|rdfs:label|= is not expanded at
compile time. To make this work, we need to add an rdf_meta/1
declaration.

  ==
  :- rdf_meta
        cardinality(r,r,-).
  ==

  * [[rdf_meta/1]]

The example below defines the rule concept/1.

  ==
  :- use_module(library(semweb/rdf_db)).  % for rdf_meta
  :- use_module(library(semweb/rdfs)).    % for rdfs_individual_of

  :- rdf_meta
	  concept(r).

  %%      concept(?C) is nondet.
  %
  %       True if C is a concept.

  concept(C) :-
	  rdfs_individual_of(C, skos:'Concept').
  ==

In addition to expanding _calls_, rdf_meta/1   also  causes expansion of
_|clause heads|_ for predicates  that  match   a  declaration.  This  is
typically used write Prolog statements   about  resources. The following
example produces three clauses with expanded (single-atom) arguments:

  ==
  :- use_module(library(semweb/rdf_db)).

  :- rdf_meta
	  label_predicate(r).

  label_predicate(rdfs:label).
  label_predicate(skos:prefLabel).
  label_predicate(skos:altLabel).
  ==
